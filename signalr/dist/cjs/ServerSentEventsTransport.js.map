{"version":3,"file":"ServerSentEventsTransport.js","sourceRoot":"","sources":["../../src/ServerSentEventsTransport.ts"],"names":[],"mappings":";AAAA,yDAAyD;AACzD,kHAAkH;AAElH,6CAA6C;AAC7C,iDAAiD;AACjD,6DAA6D;AAC7D,wDAAwD;AACxD,uEAAuE;AAEvE,kBAAkB;AAClB,iEAAiE;AACjE,+CAA+C;AAC/C,yFAAyF;AACzF,wCAAwC;AACxC,mDAAmD;AACnD,uEAAuE;AACvE,yCAAyC;AACzC,4BAA4B;AAE5B,uEAAuE;AACvE,wDAAwD;AAExD,6HAA6H;AAC7H,gGAAgG;AAChG,wCAAwC;AACxC,wDAAwD;AACxD,gCAAgC;AAChC,sDAAsD;AACtD,gEAAgE;AAEhE,iCAAiC;AACjC,+BAA+B;AAC/B,QAAQ;AAER,yFAAyF;AACzF,sCAAsC;AACtC,4DAA4D;AAC5D,sEAAsE;AAEtE,0EAA0E;AAE1E,iJAAiJ;AACjJ,0BAA0B;AAE1B,yCAAyC;AACzC,6DAA6D;AAC7D,2BAA2B;AAC3B,2GAA2G;AAC3G,gBAAgB;AAChB,YAAY;AAEZ,0DAA0D;AAC1D,kCAAkC;AAClC,4DAA4D;AAC5D,kHAAkH;AAClH,0BAA0B;AAC1B,gBAAgB;AAEhB,4CAA4C;AAC5C,gEAAgE;AAChE,iGAAiG;AACjG,uBAAuB;AACvB,mEAAmE;AACnE,wEAAwE;AACxE,kJAAkJ;AAClJ,gBAAgB;AAEhB,oBAAoB;AACpB,iEAAiE;AACjE,4CAA4C;AAC5C,gCAAgC;AAChC,mJAAmJ;AACnJ,sDAAsD;AACtD,4CAA4C;AAC5C,iDAAiD;AACjD,sCAAsC;AACtC,4BAA4B;AAC5B,wBAAwB;AACxB,qBAAqB;AAErB,+DAA+D;AAC/D,2EAA2E;AAC3E,oCAAoC;AACpC,6CAA6C;AAC7C,+BAA+B;AAC/B,yCAAyC;AACzC,wBAAwB;AACxB,qBAAqB;AAErB,+CAA+C;AAC/C,6FAA6F;AAC7F,sDAAsD;AACtD,qCAAqC;AACrC,iCAAiC;AACjC,qBAAqB;AACrB,4BAA4B;AAC5B,6BAA6B;AAC7B,0BAA0B;AAC1B,gBAAgB;AAChB,cAAc;AACd,QAAQ;AAER,oDAAoD;AACpD,mCAAmC;AACnC,gGAAgG;AAChG,YAAY;AACZ,qIAAqI;AACrI,QAAQ;AAER,qCAAqC;AACrC,wBAAwB;AACxB,oCAAoC;AACpC,QAAQ;AAER,iCAAiC;AACjC,kCAAkC;AAClC,wCAAwC;AACxC,4CAA4C;AAE5C,kCAAkC;AAClC,mCAAmC;AACnC,gBAAgB;AAChB,YAAY;AACZ,QAAQ;AACR,IAAI","sourcesContent":["// // Copyright (c) .NET Foundation. All rights reserved.\r\n// // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n// import { HttpClient } from \"./HttpClient\";\r\n// import { ILogger, LogLevel } from \"./ILogger\";\r\n// import { ITransport, TransferFormat } from \"./ITransport\";\r\n// import { EventSourceConstructor } from \"./Polyfills\";\r\n// import { Arg, getDataDetail, Platform, sendMessage } from \"./Utils\";\r\n\r\n// /** @private */\r\n// export class ServerSentEventsTransport implements ITransport {\r\n//     private readonly httpClient: HttpClient;\r\n//     private readonly accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n//     private readonly logger: ILogger;\r\n//     private readonly logMessageContent: boolean;\r\n//     private readonly eventSourceConstructor: EventSourceConstructor;\r\n//     private eventSource?: EventSource;\r\n//     private url?: string;\r\n\r\n//     public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n//     public onclose: ((error?: Error) => void) | null;\r\n\r\n//     constructor(httpClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined, logger: ILogger,\r\n//                 logMessageContent: boolean, eventSourceConstructor: EventSourceConstructor) {\r\n//         this.httpClient = httpClient;\r\n//         this.accessTokenFactory = accessTokenFactory;\r\n//         this.logger = logger;\r\n//         this.logMessageContent = logMessageContent;\r\n//         this.eventSourceConstructor = eventSourceConstructor;\r\n\r\n//         this.onreceive = null;\r\n//         this.onclose = null;\r\n//     }\r\n\r\n//     public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n//         Arg.isRequired(url, \"url\");\r\n//         Arg.isRequired(transferFormat, \"transferFormat\");\r\n//         Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n//         this.logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\r\n\r\n//         // set url before accessTokenFactory because this.url is only for send and we set the auth header instead of the query string for send\r\n//         this.url = url;\r\n\r\n//         if (this.accessTokenFactory) {\r\n//             const token = await this.accessTokenFactory();\r\n//             if (token) {\r\n//                 url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n//             }\r\n//         }\r\n\r\n//         return new Promise<void>((resolve, reject) => {\r\n//             let opened = false;\r\n//             if (transferFormat !== TransferFormat.Text) {\r\n//                 reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\r\n//                 return;\r\n//             }\r\n\r\n//             let eventSource: EventSource;\r\n//             if (Platform.isBrowser || Platform.isWebWorker) {\r\n//                 eventSource = new this.eventSourceConstructor(url, { withCredentials: true });\r\n//             } else {\r\n//                 // Non-browser passes cookies via the dictionary\r\n//                 const cookies = this.httpClient.getCookieString(url);\r\n//                 eventSource = new this.eventSourceConstructor(url, { withCredentials: true, headers: { Cookie: cookies } } as EventSourceInit);\r\n//             }\r\n\r\n//             try {\r\n//                 eventSource.onmessage = (e: MessageEvent) => {\r\n//                     if (this.onreceive) {\r\n//                         try {\r\n//                             this.logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this.logMessageContent)}.`);\r\n//                             this.onreceive(e.data);\r\n//                         } catch (error) {\r\n//                             this.close(error);\r\n//                             return;\r\n//                         }\r\n//                     }\r\n//                 };\r\n\r\n//                 eventSource.onerror = (e: MessageEvent) => {\r\n//                     const error = new Error(e.data || \"Error occurred\");\r\n//                     if (opened) {\r\n//                         this.close(error);\r\n//                     } else {\r\n//                         reject(error);\r\n//                     }\r\n//                 };\r\n\r\n//                 eventSource.onopen = () => {\r\n//                     this.logger.log(LogLevel.Information, `SSE connected to ${this.url}`);\r\n//                     this.eventSource = eventSource;\r\n//                     opened = true;\r\n//                     resolve();\r\n//                 };\r\n//             } catch (e) {\r\n//                 reject(e);\r\n//                 return;\r\n//             }\r\n//         });\r\n//     }\r\n\r\n//     public async send(data: any): Promise<void> {\r\n//         if (!this.eventSource) {\r\n//             return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n//         }\r\n//         return sendMessage(this.logger, \"SSE\", this.httpClient, this.url!, this.accessTokenFactory, data, this.logMessageContent);\r\n//     }\r\n\r\n//     public stop(): Promise<void> {\r\n//         this.close();\r\n//         return Promise.resolve();\r\n//     }\r\n\r\n//     private close(e?: Error) {\r\n//         if (this.eventSource) {\r\n//             this.eventSource.close();\r\n//             this.eventSource = undefined;\r\n\r\n//             if (this.onclose) {\r\n//                 this.onclose(e);\r\n//             }\r\n//         }\r\n//     }\r\n// }\r\n"]}