{"version":3,"file":"LongPollingTransport.js","sourceRoot":"","sources":["../../src/LongPollingTransport.ts"],"names":[],"mappings":"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","sourcesContent":["// // Copyright (c) .NET Foundation. All rights reserved.\r\n// // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n// import { AbortController } from \"./AbortController\";\r\n// import { HttpError, TimeoutError } from \"./Errors\";\r\n// import { HttpClient, HttpRequest } from \"./HttpClient\";\r\n// import { ILogger, LogLevel } from \"./ILogger\";\r\n// import { ITransport, TransferFormat } from \"./ITransport\";\r\n// import { Arg, getDataDetail, sendMessage } from \"./Utils\";\r\n\r\n// // Not exported from 'index', this type is internal.\r\n// /** @private */\r\n// export class LongPollingTransport implements ITransport {\r\n//     private readonly httpClient: HttpClient;\r\n//     private readonly accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n//     private readonly logger: ILogger;\r\n//     private readonly logMessageContent: boolean;\r\n//     private readonly pollAbort: AbortController;\r\n\r\n//     private url?: string;\r\n//     private running: boolean;\r\n//     private receiving?: Promise<void>;\r\n//     private closeError?: Error;\r\n\r\n//     public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n//     public onclose: ((error?: Error) => void) | null;\r\n\r\n//     // This is an internal type, not exported from 'index' so this is really just internal.\r\n//     public get pollAborted() {\r\n//         return this.pollAbort.aborted;\r\n//     }\r\n\r\n//     constructor(httpClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined, logger: ILogger, logMessageContent: boolean) {\r\n//         this.httpClient = httpClient;\r\n//         this.accessTokenFactory = accessTokenFactory;\r\n//         this.logger = logger;\r\n//         this.pollAbort = new AbortController();\r\n//         this.logMessageContent = logMessageContent;\r\n\r\n//         this.running = false;\r\n\r\n//         this.onreceive = null;\r\n//         this.onclose = null;\r\n//     }\r\n\r\n//     public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n//         Arg.isRequired(url, \"url\");\r\n//         Arg.isRequired(transferFormat, \"transferFormat\");\r\n//         Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n//         this.url = url;\r\n\r\n//         this.logger.log(LogLevel.Trace, \"(LongPolling transport) Connecting.\");\r\n\r\n//         // Allow binary format on Node and Browsers that support binary content (indicated by the presence of responseType property)\r\n//         if (transferFormat === TransferFormat.Binary &&\r\n//             (typeof XMLHttpRequest !== \"undefined\" && typeof new XMLHttpRequest().responseType !== \"string\")) {\r\n//             throw new Error(\"Binary protocols over XmlHttpRequest not implementing advanced features are not supported.\");\r\n//         }\r\n\r\n//         const pollOptions: HttpRequest = {\r\n//             abortSignal: this.pollAbort.signal,\r\n//             headers: {},\r\n//             timeout: 100000,\r\n//         };\r\n\r\n//         if (transferFormat === TransferFormat.Binary) {\r\n//             pollOptions.responseType = \"arraybuffer\";\r\n//         }\r\n\r\n//         const token = await this.getAccessToken();\r\n//         this.updateHeaderToken(pollOptions, token);\r\n\r\n//         // Make initial long polling request\r\n//         // Server uses first long polling request to finish initializing connection and it returns without data\r\n//         const pollUrl = `${url}&_=${Date.now()}`;\r\n//         this.logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\r\n//         const response = await this.httpClient.get(pollUrl, pollOptions);\r\n//         if (response.statusCode !== 200) {\r\n//             this.logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\r\n\r\n//             // Mark running as false so that the poll immediately ends and runs the close logic\r\n//             this.closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n//             this.running = false;\r\n//         } else {\r\n//             this.running = true;\r\n//         }\r\n\r\n//         this.receiving = this.poll(this.url, pollOptions);\r\n//     }\r\n\r\n//     private async getAccessToken(): Promise<string | null> {\r\n//         if (this.accessTokenFactory) {\r\n//             return await this.accessTokenFactory();\r\n//         }\r\n\r\n//         return null;\r\n//     }\r\n\r\n//     private updateHeaderToken(request: HttpRequest, token: string | null) {\r\n//         if (!request.headers) {\r\n//             request.headers = {};\r\n//         }\r\n//         if (token) {\r\n//             // tslint:disable-next-line:no-string-literal\r\n//             request.headers[\"Authorization\"] = `Bearer ${token}`;\r\n//             return;\r\n//         }\r\n//         // tslint:disable-next-line:no-string-literal\r\n//         if (request.headers[\"Authorization\"]) {\r\n//             // tslint:disable-next-line:no-string-literal\r\n//             delete request.headers[\"Authorization\"];\r\n//         }\r\n//     }\r\n\r\n//     private async poll(url: string, pollOptions: HttpRequest): Promise<void> {\r\n//         try {\r\n//             while (this.running) {\r\n//                 // We have to get the access token on each poll, in case it changes\r\n//                 const token = await this.getAccessToken();\r\n//                 this.updateHeaderToken(pollOptions, token);\r\n\r\n//                 try {\r\n//                     const pollUrl = `${url}&_=${Date.now()}`;\r\n//                     this.logger.log(LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\r\n//                     const response = await this.httpClient.get(pollUrl, pollOptions);\r\n\r\n//                     if (response.statusCode === 204) {\r\n//                         this.logger.log(LogLevel.Information, \"(LongPolling transport) Poll terminated by server.\");\r\n\r\n//                         this.running = false;\r\n//                     } else if (response.statusCode !== 200) {\r\n//                         this.logger.log(LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\r\n\r\n//                         // Unexpected status code\r\n//                         this.closeError = new HttpError(response.statusText || \"\", response.statusCode);\r\n//                         this.running = false;\r\n//                     } else {\r\n//                         // Process the response\r\n//                         if (response.content) {\r\n//                             this.logger.log(LogLevel.Trace, `(LongPolling transport) data received. ${getDataDetail(response.content, this.logMessageContent)}.`);\r\n//                             if (this.onreceive) {\r\n//                                 this.onreceive(response.content);\r\n//                             }\r\n//                         } else {\r\n//                             // This is another way timeout manifest.\r\n//                             this.logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n//                         }\r\n//                     }\r\n//                 } catch (e) {\r\n//                     if (!this.running) {\r\n//                         // Log but disregard errors that occur after stopping\r\n//                         this.logger.log(LogLevel.Trace, `(LongPolling transport) Poll errored after shutdown: ${e.message}`);\r\n//                     } else {\r\n//                         if (e instanceof TimeoutError) {\r\n//                             // Ignore timeouts and reissue the poll.\r\n//                             this.logger.log(LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\r\n//                         } else {\r\n//                             // Close the connection with the error as the result.\r\n//                             this.closeError = e;\r\n//                             this.running = false;\r\n//                         }\r\n//                     }\r\n//                 }\r\n//             }\r\n//         } finally {\r\n//             this.logger.log(LogLevel.Trace, \"(LongPolling transport) Polling complete.\");\r\n\r\n//             // We will reach here with pollAborted==false when the server returned a response causing the transport to stop.\r\n//             // If pollAborted==true then client initiated the stop and the stop method will raise the close event after DELETE is sent.\r\n//             if (!this.pollAborted) {\r\n//                 this.raiseOnClose();\r\n//             }\r\n//         }\r\n//     }\r\n\r\n//     public async send(data: any): Promise<void> {\r\n//         if (!this.running) {\r\n//             return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n//         }\r\n//         return sendMessage(this.logger, \"LongPolling\", this.httpClient, this.url!, this.accessTokenFactory, data, this.logMessageContent);\r\n//     }\r\n\r\n//     public async stop(): Promise<void> {\r\n//         this.logger.log(LogLevel.Trace, \"(LongPolling transport) Stopping polling.\");\r\n\r\n//         // Tell receiving loop to stop, abort any current request, and then wait for it to finish\r\n//         this.running = false;\r\n//         this.pollAbort.abort();\r\n\r\n//         try {\r\n//             await this.receiving;\r\n\r\n//             // Send DELETE to clean up long polling on the server\r\n//             this.logger.log(LogLevel.Trace, `(LongPolling transport) sending DELETE request to ${this.url}.`);\r\n\r\n//             const deleteOptions: HttpRequest = {\r\n//                 headers: {},\r\n//             };\r\n//             const token = await this.getAccessToken();\r\n//             this.updateHeaderToken(deleteOptions, token);\r\n//             await this.httpClient.delete(this.url!, deleteOptions);\r\n\r\n//             this.logger.log(LogLevel.Trace, \"(LongPolling transport) DELETE request sent.\");\r\n//         } finally {\r\n//             this.logger.log(LogLevel.Trace, \"(LongPolling transport) Stop finished.\");\r\n\r\n//             // Raise close event here instead of in polling\r\n//             // It needs to happen after the DELETE request is sent\r\n//             this.raiseOnClose();\r\n//         }\r\n//     }\r\n\r\n//     private raiseOnClose() {\r\n//         if (this.onclose) {\r\n//             let logMessage = \"(LongPolling transport) Firing onclose event.\";\r\n//             if (this.closeError) {\r\n//                 logMessage += \" Error: \" + this.closeError;\r\n//             }\r\n//             this.logger.log(LogLevel.Trace, logMessage);\r\n//             this.onclose(this.closeError);\r\n//         }\r\n//     }\r\n// }\r\n"]}