{"version":3,"file":"WeChatWebSocketTransport.js","sourceRoot":"","sources":["../../src/WeChatWebSocketTransport.ts"],"names":[],"mappings":"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","sourcesContent":["import { HttpClient } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail } from \"./Utils\";\r\n\r\nexport class WeChatWebSocketTransport implements ITransport {\r\n\r\n    private webSocket: WechatMiniprogram.SocketTask | undefined;\r\n    constructor(\r\n        private readonly httpClient: HttpClient,\r\n        private readonly accessTokenFactory: (() => string | Promise<string>) | undefined,\r\n        private readonly logger: ILogger,\r\n        private readonly logMessageContent: boolean) {\r\n\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this.logger.log(LogLevel.Trace, \"(WebSockets transport) Connecting.\");\r\n\r\n        if (this.accessTokenFactory) {\r\n            const token = await this.accessTokenFactory();\r\n            if (token) {\r\n                url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n            }\r\n        }\r\n        return new Promise<void>((resolve, reject) => {\r\n            url = url.replace(/^http/, \"ws\");\r\n            let webSocket: WechatMiniprogram.SocketTask | undefined;\r\n            const cookies = this.httpClient.getCookieString(url);\r\n\r\n            webSocket = wx.connectSocket({\r\n                url,\r\n                header: {\r\n                    cookie: cookies ? `${cookies}` : undefined,\r\n                }\r\n            });\r\n\r\n            // wechat doesn't support this kind of api\r\n            // if (transferFormat === TransferFormat.Binary) {\r\n            //     webSocket.binaryType = \"arraybuffer\";\r\n            // }\r\n\r\n            // tslint:disable-next-line:variable-name\r\n            webSocket.onOpen(() => {\r\n                this.logger.log(LogLevel.Information, `WebSocket connected to ${url}.`);\r\n                this.webSocket = webSocket;\r\n                resolve();\r\n            });\r\n\r\n            webSocket.onError((event) => {\r\n                let error: any = null;\r\n                // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                error = event.errMsg;\r\n                if (!error) {\r\n                    error = new Error(\"There was an error with the transport.\");\r\n                }\r\n                reject(error);\r\n            });\r\n\r\n            webSocket.onMessage((message) => {\r\n                this.logger.log(LogLevel.Trace, `(WebSockets transport) data received. ${getDataDetail(message.data, this.logMessageContent)}.`);\r\n                if (this.onreceive) {\r\n                    this.onreceive(message.data);\r\n                }\r\n            });\r\n\r\n            webSocket.onClose((event) => this.close(event));\r\n        });\r\n\r\n    }\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null = null;\r\n    public onclose: ((error?: Error | undefined) => void) | null = null;\r\n\r\n    public send(data: any): Promise<void> {\r\n        if (this.webSocket) {\r\n            this.logger.log(LogLevel.Trace, `(WebSockets transport) sending data. ${getDataDetail(data, this.logMessageContent)}.`);\r\n            this.webSocket.send({ data });\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return Promise.reject(\"WebSocket is not in the OPEN state\");\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        if (this.webSocket) {\r\n            // Clear websocket handlers because we are considering the socket closed now\r\n            this.webSocket = undefined;\r\n\r\n            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\r\n            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\r\n            this.close(undefined);\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private close(event?: WechatMiniprogram.SocketTaskOnCloseCallbackResult): void {\r\n        // webSocket will be null if the transport did not start successfully\r\n        this.logger.log(LogLevel.Trace, \"(WebSockets transport) socket closed.\");\r\n        if (this.onclose) {\r\n            if (event && event.code !== 1000) {\r\n                this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason}).`));\r\n            } else {\r\n                this.onclose();\r\n            }\r\n        }\r\n    }\r\n}\r\n"]}